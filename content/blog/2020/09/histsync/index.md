---
title: ShellのhistoryファイルをGitで管理するスクリプトを書いた
date: '2020-09-14T:12:53Z'
tags: [zsh, shell, unix]
---

Shell の history を Git で管理すると、複数のマシンで同じ履歴をたどることができるので便利です。

今回の主な動機は、最近メインの開発環境を Ubuntu 20.04 に引っ越しをしたことです。  
以前の開発環境である Ubuntu 18.04 も残したためふたつの(仮想)環境を横断して管理したくなったからです。

スクリプトはここにおいてあります。今後更新する可能性もあるのでそのときは master を見に行ってください。

[dotfiles/histsync at e546032f4ec62813952be8f07b58bd237a208463 · anoriqq/dotfiles](https://github.com/anoriqq/dotfiles/blob/e546032f4ec62813952be8f07b58bd237a208463/histsync)

やっていることは、

- リモートの history ファイルを持ってくる
- マージする
- ソートする

の処理です。

簡単そうだと思って始めたのですが、思いの外複雑になってしまいました。  
もっと美しくかける方のPRお待ちしてます。

#### 複数行コマンドのマージ

ここからは、作成の中で最も難しかったことの話です。

対象の Shell は `zsh` として進めます。

`zsh` の history 形式は オプションにもよりますが、`extended_history` を有効にしている場合次のようになります。

```text
# : 実行時刻:実行時間;コマンド
: 1599636013:0;echo 'hogehoge'
```

これなら単純に `sort` と `uniq` を実行すれば済みそうです。

問題は改行を含む複数行のコマンドの history です。  
次のようになります。

```text
: 1599636013:0;if [ 0 -eq 0 ];then\
echo 'hugahuga'\
fi
```

このように行頭がコマンドになってしまいます。

この複数行のコマンドを処理問題なく処理するために、マージ部分では次のように処理しています。

1. リモートの history と ローカルの history を単純に結合したものからふたつのファイルをつくる
	- `: 実行時刻` のような形式で始まらない行を取り除いたもの
	- 複数行コマンドだけを抽出したもの
2. 複数行コマンドのファイルをコマンドの形が崩れないように `sort` と `uniq` する
3. もとのコマンド位置を探して挿入する

これで形が崩れることなく複数の history ファイルをマージできました。

学んだことは、

- `tee` でファイルを操作してはいけない。

リダイレクト先のプロセスが何をやっているのか確認することができなくて、僕の能力では制御不能でした。
ファイルが作成される前に探してたりしました。

- history ファイルを `grep` するときは `-a` オプションをつける。

`grep` にバイナリファイルだと認識されます。
今回の実装では標準出力を使ってプロセスをつないでいたので、`Binary file (standard input) matches` という文字列が history ファイルに混入しました。

- 複数行に渡るブロックを形を崩さずにソートするには行頭に識別番号なりを追加してからソートするとうまくいく

そのままです。このやりかたに気づいて良かったです。

- 特定の行数に挿入するときは下の行(行番号の大きい方)から

挿入のたびに行数がずれないので楽です。僕は逆順のソートのオプションが正しく機能してないのに逆に挿入してると思い込んでいたので、無意味な戦いをしていました。

- `sort` コマンドで列指定かつ逆順にするときは `-k` の引数に `-r` オプションを指定する(自戒)

`sort -r -k 3,3` ではなく、`sort -k 3r,3`。

#### 感想

またひとつ妄想が実現できました。

cron に登録しておくと便利です。

